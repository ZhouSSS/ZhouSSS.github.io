{"Linux系统配置与调优/CentOS7.9-命令杂项":{"slug":"Linux系统配置与调优/CentOS7.9-命令杂项","filePath":"Linux系统配置与调优/CentOS7.9 命令杂项.md","title":"CentOS命令杂项","links":[],"tags":["CentOS","Linux"],"content":"\n1.1 VMware虚拟机配置\n\n开机无ip问题：\n\n1.确认网卡名\nip a\n \n2.编辑网卡配置文件\nsudo vi sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33\n \n修改配置如下：主要是ONBOOT=yes\nTYPE=Ethernet\nBOOTPROTO=dhcp\nNAME=ens33\nDEVICE=ens33\nONBOOT=yes\n \n3.重启后可自动分配ip\n1.2 配置ssh+root远程连接\n1.配置root用户密码\nsudo passwd root\n \n2.编辑ssh配置文件\nvi /etc/ssh/sshd_config\n \n3.修改PermitRootLogin项为yes,允许root用户登录\n \n4.systemctl restart sshd\n1.3 配置代理服务\n1.添加环境变量\nvi /etc/profile\n//或\nvi ~/.bashrc\n \n2.添加两行:\nexport http_proxy=&quot;http://ip:port&quot;\nexport https_proxy=&quot;http://ip:port&quot;\n \n3.环境变量生效\nsource /etc/profile\n//或\nsource ~/.bashrc\n \n4.docker代理需单独配置\nmkdir -p /etc/systemd/system/docker.service.d/ &amp;&amp; sudo touch /etc/systemd/system/docker.service.d/proxy.conf\n添加代理：\nsudo bash -c &#039;cat &gt; /etc/systemd/system/proxy.conf &lt;&lt;EOF\n[Service]\nEnvironment=&quot;HTTP_PROXY=http://ip:port/&quot;\nEnvironment=&quot;HTTPS_PROXY=http://ip:port/&quot;\nEnvironment=&quot;NO_PROXY=localhost,127.0.0.1&quot;\nEOF&#039;\n1.4 制作离线安装包\n\nCentOS递归下载目标安装包和其所有依赖包\n\n1.安装yum插件\nyum install -y yum-utils\n \n2.将&quot;目标安装包名&quot; 替换为要下载的包名 destdir为包下载目录(当前目录)\n(echo 目标安装包名;repoquery --requires --resolve --recursive --plugins --qf &quot;%{name}&quot; 目标安装包名;) | sort -u | xargs yumdownloader --destdir=./offline-pkg\n \n3.查看下载路径下包含所有的rpm包，打包带走\ntar zcvf offline-pkg.tar.gz ./offline-pkg/\n \n4.转移到新机器后\ntar zxvf offline-pkg.tar.gz\ncd offline-pkg\nsudo yum localinstall *.rpm\n注意：\n\n以下命令为递归查找目标的依赖包并下载，并不包括目标本身，因此需将目标包一并添加到依赖项中\n\nsudo repoquery --requires --resolve --recursive --plugins --qf &quot;%{name}&quot; 目标安装包名 | sort -u | xargs yumdownloader --destdir=.\n\nC++调优\n编译链接命令\n-fno-exceptions -fno-rtti -nostdlib++"},"index":{"slug":"index","filePath":"index.md","title":"我的主页","links":["cn/"],"tags":[],"content":"欢迎来到我的博客！\n\n中文页面\n\n\n  \n    🎯 要有目标\n    确定清晰的目标（短期可行、长期宏大），作为优化方向。\n  \n  \n    🚀 目标要大\n    别只设易达成的目标，远大的目标避免过早收敛到“简单解”。\n  \n  \n    🏃 坚持走\n    每次估计一个方向，迈小步，重复执行。持续比单次完美更重要。\n  \n  \n    🔥 痛苦的卷\n    改变常伴痛苦，但不改变就没有成长；辨别有价值的痛苦。\n  \n  \n    🛌 可以躺平\n    步长要平衡：太小停滞，太大耗尽激情。周期性调整并允许休息。\n  \n  \n    🔍 四处看看\n    随机性与试错帮助跳出局部，扩大视野与可能性。\n  \n  \n    ⏳ 快也是慢\n    前期太快可能导致后期乏力；允许前期徘徊来保留长期动能。\n  \n  \n    🏁 赢在起点\n    起点优势是真实存在的，识别并利用它，同时保持谦逊。\n  \n  \n    🛣 很远也能到达\n    起点远并非不可达，随机重启与耐心会带来收敛。\n  \n  \n    ✨ 独一无二\n    过程参数（你的选择）是独特的，尊重并记录你的路径。\n  \n  \n    🧩 简单最好\n    复杂策略先放一边，先用简单可复现的方法不断迭代。\n  \n\n"},"python/libclang代码生成":{"slug":"python/libclang代码生成","filePath":"python/libclang代码生成.md","title":"libclang代码生成","links":[],"tags":["Utils","Python"],"content":"安装clang工具链\nsudo apt-get install clang-10 lldb-10 lld-10\npython安装相关包\npip install clang==10.0.1\nclang++ 命令生成抽象语法树\n#打印AST\nclang++ -Xclang -ast-dump -fsyntax-only 目标文件.h\n \n#将AST保存到二进制文件(目标文件.h.gch)\nclang++ -emit-ast 目标文件.h\n例：\n//待解析源文件\nclass Box\n{\n   public:\n      double length;   // 长度\n      double breadth;  // 宽度\n      double height;   // 高度\n      // 成员函数声明\n      double get(void);\n      void set( double len, double bre, double hei );\n};\n// 成员函数定义\ndouble Box::get(void)\n{\n    return length * breadth * height;\n}\n \nvoid Box::set( double len, double bre, double hei)\n{\n    length = len;\n    breadth = bre;\n    height = hei;\n}\n#生成代码如下\nTranslationUnitDecl 0x3a8f2048 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;\n|-TypedefDecl 0x3a8f2920 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t &#039;__int128&#039;\n| `-BuiltinType 0x3a8f25e0 &#039;__int128&#039;\n|-TypedefDecl 0x3a8f2990 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t &#039;unsigned __int128&#039;\n| `-BuiltinType 0x3a8f2600 &#039;unsigned __int128&#039;\n|-TypedefDecl 0x3a8f2d08 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString &#039;__NSConstantString_tag&#039;\n| `-RecordType 0x3a8f2a80 &#039;__NSConstantString_tag&#039;\n|   `-CXXRecord 0x3a8f29e8 &#039;__NSConstantString_tag&#039;\n|-TypedefDecl 0x3a8f2da0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list &#039;char *&#039;\n| `-PointerType 0x3a8f2d60 &#039;char *&#039;\n|   `-BuiltinType 0x3a8f20e0 &#039;char&#039;\n|-TypedefDecl 0x3a930018 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list &#039;__va_list_tag [1]&#039;\n| `-ConstantArrayType 0x3a92ffc0 &#039;__va_list_tag [1]&#039; 1 \n|   `-RecordType 0x3a8f2e90 &#039;__va_list_tag&#039;\n|     `-CXXRecord 0x3a8f2df8 &#039;__va_list_tag&#039;\n|-CXXRecordDecl 0x3a930070 &lt;../codegen/box.h:1:1, line:10:1&gt; line:1:7 class Box definition\n| |-DefinitionData pass_in_registers aggregate standard_layout trivially_copyable pod trivial literal\n| | |-DefaultConstructor exists trivial needs_implicit\n| | |-CopyConstructor simple trivial has_const_param needs_implicit implicit_has_const_param\n| | |-MoveConstructor exists simple trivial needs_implicit\n| | |-CopyAssignment trivial has_const_param needs_implicit implicit_has_const_param\n| | |-MoveAssignment exists simple trivial needs_implicit\n| | `-Destructor simple irrelevant trivial needs_implicit\n| |-CXXRecordDecl 0x3a930188 &lt;col:1, col:7&gt; col:7 implicit class Box\n| |-AccessSpecDecl 0x3a930218 &lt;line:3:4, col:10&gt; col:4 public\n| |-FieldDecl 0x3a930258 &lt;line:4:7, col:14&gt; col:14 referenced length &#039;double&#039;\n| |-FieldDecl 0x3a9302c0 &lt;line:5:7, col:14&gt; col:14 referenced breadth &#039;double&#039;\n| |-FieldDecl 0x3a930328 &lt;line:6:7, col:14&gt; col:14 referenced height &#039;double&#039;\n| |-CXXMethodDecl 0x3a930470 &lt;line:8:7, col:22&gt; col:14 get &#039;double ()&#039;\n| `-CXXMethodDecl 0x3a930708 &lt;line:9:7, col:52&gt; col:12 set &#039;void (double, double, double)&#039;\n|   |-ParmVarDecl 0x3a930528 &lt;col:17, col:24&gt; col:24 len &#039;double&#039;\n|   |-ParmVarDecl 0x3a9305a8 &lt;col:29, col:36&gt; col:36 bre &#039;double&#039;\n|   `-ParmVarDecl 0x3a930628 &lt;col:41, col:48&gt; col:48 hei &#039;double&#039;\n|-CXXMethodDecl 0x3a930898 parent 0x3a930070 prev 0x3a930470 &lt;line:12:1, line:15:1&gt; line:12:13 get &#039;double ()&#039;\n| `-CompoundStmt 0x3a930ae0 &lt;line:13:1, line:15:1&gt;\n|   `-ReturnStmt 0x3a930ad0 &lt;line:14:5, col:31&gt;\n|     `-BinaryOperator 0x3a930ab0 &lt;col:12, col:31&gt; &#039;double&#039; &#039;*&#039;\n|       |-BinaryOperator 0x3a930a38 &lt;col:12, col:21&gt; &#039;double&#039; &#039;*&#039;\n|       | |-ImplicitCastExpr 0x3a930a08 &lt;col:12&gt; &#039;double&#039; &lt;LValueToRValue&gt;\n|       | | `-MemberExpr 0x3a930998 &lt;col:12&gt; &#039;double&#039; lvalue -&gt;length 0x3a930258\n|       | |   `-CXXThisExpr 0x3a930988 &lt;col:12&gt; &#039;Box *&#039; implicit this\n|       | `-ImplicitCastExpr 0x3a930a20 &lt;col:21&gt; &#039;double&#039; &lt;LValueToRValue&gt;\n|       |   `-MemberExpr 0x3a9309d8 &lt;col:21&gt; &#039;double&#039; lvalue -&gt;breadth 0x3a9302c0\n|       |     `-CXXThisExpr 0x3a9309c8 &lt;col:21&gt; &#039;Box *&#039; implicit this\n|       `-ImplicitCastExpr 0x3a930a98 &lt;col:31&gt; &#039;double&#039; &lt;LValueToRValue&gt;\n|         `-MemberExpr 0x3a930a68 &lt;col:31&gt; &#039;double&#039; lvalue -&gt;height 0x3a930328\n|           `-CXXThisExpr 0x3a930a58 &lt;col:31&gt; &#039;Box *&#039; implicit this\n`-CXXMethodDecl 0x3a930cb8 parent 0x3a930070 prev 0x3a930708 &lt;line:17:1, line:22:1&gt; line:17:11 set &#039;void (double, double, double)&#039;\n  |-ParmVarDecl 0x3a930b18 &lt;col:16, col:23&gt; col:23 used len &#039;double&#039;\n  |-ParmVarDecl 0x3a930b98 &lt;col:28, col:35&gt; col:35 used bre &#039;double&#039;\n  |-ParmVarDecl 0x3a930c18 &lt;col:40, col:47&gt; col:47 used hei &#039;double&#039;\n  `-CompoundStmt 0x3a95e1c8 &lt;line:18:1, line:22:1&gt;\n    |-BinaryOperator 0x3a930e38 &lt;line:19:5, col:14&gt; &#039;double&#039; lvalue &#039;=&#039;\n    | |-MemberExpr 0x3a930dd0 &lt;col:5&gt; &#039;double&#039; lvalue -&gt;length 0x3a930258\n    | | `-CXXThisExpr 0x3a930dc0 &lt;col:5&gt; &#039;Box *&#039; implicit this\n    | `-ImplicitCastExpr 0x3a930e20 &lt;col:14&gt; &#039;double&#039; &lt;LValueToRValue&gt;\n    |   `-DeclRefExpr 0x3a930e00 &lt;col:14&gt; &#039;double&#039; lvalue ParmVar 0x3a930b18 &#039;len&#039; &#039;double&#039;\n    |-BinaryOperator 0x3a930ed0 &lt;line:20:5, col:15&gt; &#039;double&#039; lvalue &#039;=&#039;\n    | |-MemberExpr 0x3a930e68 &lt;col:5&gt; &#039;double&#039; lvalue -&gt;breadth 0x3a9302c0\n    | | `-CXXThisExpr 0x3a930e58 &lt;col:5&gt; &#039;Box *&#039; implicit this\n    | `-ImplicitCastExpr 0x3a930eb8 &lt;col:15&gt; &#039;double&#039; &lt;LValueToRValue&gt;\n    |   `-DeclRefExpr 0x3a930e98 &lt;col:15&gt; &#039;double&#039; lvalue ParmVar 0x3a930b98 &#039;bre&#039; &#039;double&#039;\n    `-BinaryOperator 0x3a95e1a8 &lt;line:21:5, col:14&gt; &#039;double&#039; lvalue &#039;=&#039;\n      |-MemberExpr 0x3a95e140 &lt;col:5&gt; &#039;double&#039; lvalue -&gt;height 0x3a930328\n      | `-CXXThisExpr 0x3a930ef0 &lt;col:5&gt; &#039;Box *&#039; implicit this\n      `-ImplicitCastExpr 0x3a95e190 &lt;col:14&gt; &#039;double&#039; &lt;LValueToRValue&gt;\n        `-DeclRefExpr 0x3a95e170 &lt;col:14&gt; &#039;double&#039; lvalue ParmVar 0x3a930c18 &#039;hei&#039; &#039;double&#039;"},"python/python打包":{"slug":"python/python打包","filePath":"python/python打包.md","title":"python打包","links":[],"tags":["Python","Utils"],"content":"安装pyinstaller工具\npip install pyinstaller==6.2.0\n#装别的版本,打包带--noconsole会报错 \n#(225, &#039;&#039;, &#039;无法成功完成操作，因为文件包含病毒或潜在的垃圾软件。&#039;) \n打包单python文件加配置文件\npyinstaller --onefile --add-data &quot;config.ini;.&quot; DbxController.py --noconsole\n#--noconsole 打包后不会有终端窗口"},"tools/C++程序内存泄漏及性能检测":{"slug":"tools/C++程序内存泄漏及性能检测","filePath":"tools/C++程序内存泄漏及性能检测.md","title":"C++程序内存泄漏及性能检测","links":[],"tags":["Utils","CPP"],"content":"一、安装\n#安装 valgrind\nsudo apt-get install valgrind  # Debian/Ubuntu\nsudo yum install valgrind      # CentOS/Fedora\n#安装 massif-visualizer\nsudo apt install massif-visualizer\n二、检测内存泄漏\n1.基本介绍\n\n\n（1）Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。\n（2）Callgrind。它主要用来检查程序中函数调用过程中出现的问题。\n（3）Cachegrind。它主要用来检查程序中缓存使用出现的问题。\n（4）Helgrind。它主要用来检查多线程程序中出现的竞争问题。\n（5）Massif。它主要用来检查程序中堆栈使用中出现的问题。\n（6）Extension。可以利用core提供的功能，自己编写特定的内存调试工具\n（7）其他 valgrind插件用法: valgrind插件用法\n\n\n2.使用valgrind\nvalgrind --leak-check=full --show-leak-kinds=all --track-origins=yes xxx args ...\n进程退出后，会生成日志信息，可查看内存泄漏情况及泄漏位置\n3.使用valgrind+massif\n# 生成massif.out.xxx文件\nvalgrind --tool=massif xxx args ...\n#使用massif-visualizer查看进程内存增长\nmassif-visualizer massif.out.12345\n#或 \nms_print massif.out.12345 \n\n4.为何需要两种方式检测？\n\n\n第一种方式，进程调用某库函数分配内存不释放， 但是在进程退出时，统一释放内存，valgrind 检查不出来\n第二种方式，使用massif工具进行全过程检测，可有效跟踪服务内存不断增长的情况\n\n"},"云计算/DevOps/GitLab、Jenkins部署与CICD搭建":{"slug":"云计算/DevOps/GitLab、Jenkins部署与CICD搭建","filePath":"云计算/DevOps/GitLab、Jenkins部署与CICD搭建.md","title":"GitLab、Jenkins部署与CICD搭建","links":["Linux系统配置与调优/CentOS7.9-命令杂项"],"tags":["云原生","Docker"],"content":"\n一、简介\n配置环境如下：\n系统问题、代理配置等请参考CentOS7.9 命令杂项\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n系统及软件环境版本CentOS7.9Docker20以上的版本即可GitLab镜像gitlab/gitlab-ce:16.1.0-ce.0Jenkins镜像jenkins/jenkins:lts\n\n二、GitLab部署配置\n1. 运行GitLab容器\n\n\n                  \n                  NOTICE\n                  \n                \n\n\n1）—privileged 若运行时Gitlab容器一直重启，添加可解决\n2）8080:80  外部http访问端口变为8080，2222:22 外部ssh访问端口变为2222\n3）将持久化文件路径挂载出来（你也不想代码仓库随着容器一起消失吧 😰）\n\n\n\ndocker run -d \\\n\t--privileged  --hostname localhost \\\n\t-p 8080:80  -p 2222:22  --name gitlab \\\n\t--restart always   \\\n\t-v /opt/gitlab/config:/etc/gitlab   \\\n\t-v /opt/gitlab/logs:/var/log/gitlab   \\\n\t-v /opt/gitlab/data:/var/opt/gitlab   \\\n\tgitlab/gitlab-ce:16.1.0-ce.0\n2. 修改GitLab容器内部配置\n\n进入容器内部：\n\ndocker exec -it gitlab bash\n\n修改文件：\n\nvi /etc/gitlab/gitlab.rb\n\n添加如下配置项：\n\ngitlab_rails[&#039;gitlab_shell_ssh_port&#039;] = 外部ssh访问端口                 \nexternal_url &#039;http://宿主机或公网ip:外部http访问端口&#039;                    \nnginx[&#039;listen_port&#039;] = 容器内gitlab服务端口\n \n例子:\ngitlab_rails[&#039;gitlab_shell_ssh_port&#039;] = 2222                     \nexternal_url &#039;http://192.168.137.11:8080&#039;                          \nnginx[&#039;listen_port&#039;] = 80\n\n\n                  \n                  WARNING\n                  \n                \n\n\n以上ip和port配置是与运行容器时的配置相关\n\\qquad 1.若为更改http和ssh端口，则无需更改。其中修改gitlab_rails与external_url，在复制git仓库的clone地址时，直接相关，当复制clone地址时，则会变为\nssh://git@外部ip:外部ssh端口/用户/项目.git 和\nhttp://外部ip:外部http端口/用户/项目.git\n\\qquad 2.如果更改了外部http端口，external_url ‘http://192.168.137.11:8080’ 配置项改成带端口的，改成非80端口，则必须添加 nginx[‘listen_port’] = 80 ，因为external_url带端口则会让容器内的nginx监听改的端口，但运行容器时是 -p 8080:80，则外部一定访问不到Gitlab服务\n\\qquad 3.nginx[‘listen_port’] 此项在更改外部http端口时，必须添加，否则外部访问不到Gitlab服务\n\n\n\n//修改另一配置 （顺便修改下吧）\nvi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\n//ssh外部端口\nssh_port: 2222\n\n配置生效、重启Gitlab服务\n\n//在容器内 重新生成配置\ngitlab-ctl reconfigure\n//重启服务\ngitlab-ctl restart\n\n此时外部网页http://ip:port能够访问到Gitlab服务了\n\n3. 配置管理员用户\n\n进入容器内部\n\ncd /opt/gitlab/bin\ngitlab-rails console //等待初始化密码\n\n终端输入，查找管理员用户\n\nu=User.where(id:1).first\n//可以查看到管理员用户名，一般为root\n\n设置管理员密码\n\nu.password=&#039;xxxxxxxxx&#039;\n\n确认密码\n\nu.password_confirmation=&#039;xxxxxxxxx&#039;\n\n保存修改\n\nu.save!\n4. 创建新用户与项目仓库\n\n注册新用户，使用管理员认证通过\n创建代码仓库\n本地与git仓库关联\n创建ssh公钥私钥\n\nssh-keygen -o -t rsa -b 2048 -C &quot;email@example.com&quot;\n\n将生成的id_rsa.pub复制到代码仓库的SSH Keys上\n\n\n\n                  \n                  WARNING\n                  \n                \n\n\n\\qquad如果Gitlab与Jenkins部署在内网，那么需要使用管理员配置出站请求\n\\qquad步骤如下(管理员登录)：\nAdmin area → Setting → Network → Outbound requests\n勾选允许webhook出站到内网地址\n\n\n\n\n三、Jenkins部署与配置\n1.运行Jenkins容器\ndocker run -d --name=jenkins \\\n-p 8080:8080 \\\n-u root \\\n--restart always \\ n\n-v /var/run/docker.sock:/var/run/docker.sock \\\n-v /usr/bin/docker:/usr/bin/docker \\\n-v /opt/jenkins_home:/var/jenkins_home \\\njenkins/jenkins:lts\n2.配置Jenkins\n2.1获取管理员密码，网页访问并输入密码解锁Jenkins\ncat /opt/jenkins_home/secrets/initialAdminPassword\n或者进入容器\ncat /var/jenkins_home/secrets/initialAdminPassword\n2.2 安装插件\n1）直接选安装推荐插件，等待安装完毕\n2）创建管理员用户 admin\n3）安装其他插件\n系统管理 → 插件管理 → 可选插件搜索框，搜索并安装以下插件：\n\nGitlab   Gitlab API\nDocker\nPublish Over SSH\n\n2.3创建Jenkins任务\n2.3.1 创建freestyle项目\n输入项目名称xxx，选择freestyle项目。名字最好能与Gitlab的项目对应\n2.3.2 配置freestyle项目\n2.3.2.1 配置源码管理\n源码管理选择Git\n\\qquadRepository URL：此处可以填入Gitlab项目的ssh或者http两种地址区别为\n\\qquad 1）填入http地址，则Jenkins凭证选择Gitlab创建项目的用户或有权限提交的用户和其密码连接Github\n\\qquad 2）填入ssh地址，则在Jenkins凭证中用户填入git，私钥选择与Gitlab项目配对的私钥，且需要在容器内使用私钥连接一次后，添加目标服务器的指纹到known_hosts文件中，网页配置生效。\n\\qquad私钥挂载或复制进容器，进入容器执行后，可添加目标服务器的指纹到known_hosts文件：\nssh -i /path/to/private_key -p 2222 git形式的项目地址\n2.3.2.2 配置触发器\n\n勾选Build when a change is pushed to GitLab … 同时记得 GitLab webhook URL\n下翻点击Generate，生成token\n切到Gitlab，在项目中Setting → Webhooks，填入上述URL和token，勾选适当的触发条件(Push events等)，下拉最后点击确定，生成webhooks，点击edit后，能看到历史触发的详细信息。点击test，可以发送对应的触发事件，用来手动测试联通Jenkins的流水线或其他任务\n\n2.3.2.3 配置构建\n\\qquad这里主要是配置C++/CMake构建项目。所以 build step 勾选 执行shell\n输入如下：\n#!/bin/bash\nset -ex\n \nHOST_PATH=&quot;/opt/jenkins_home/workspace/hello&quot;\n \ndocker run --rm \\\n  -v &quot;$HOST_PATH&quot;:/build \\\n  -w /build \\\n  cpp-build-image:v1 bash ./build.sh\n\\qquad本地自行准备好编译环境的镜像，另外此处是Jenkins容器挂载目录/opt/jenkins_home:/var/jenkins_home，相应的Jenkins拉取的Gitlab项目会在容器内的/var/jenkins_home/workspace/项目名 ，也就是宿主机的/opt/jenkins_home/workspace/项目名，选择运行编译容器时，将Gitlab项目目录由宿主机挂载进编译容器，且工作目录进入项目目录下，此处需开发人员将构建命令自行准备好，且随项目一同提交进Gitlab。执行过程中，编译完成的可执行文件和库都会在宿主机的/opt/jenkins_home/workspace/项目名 目录下，取决于 build.sh的构建细节。后续可将构建的产物继续打包或上传\n\n\n                  \n                  Jenkins的构建步骤里，build step可以是一个或多个，因此可以拆分多步，也可以一步构建完，然后使用docker build打包 \n                  \n                \n\n\n\n                  \n                  build step比较自由，主要服务于最终的目的，能达成目的即可 \n                  \n                \n\n\n四、 完成整个CI/CD\n\\qquad配置步骤走到这里，已经完成了CI的全部内容了\n\n此时可以测试，通过Gitlab项目的Setting → WebHooks → 下面配置好的trigger，点击test，触发相应的事件，可以看Jenkins的任务是否触发，是否执行成功\ngit提交代码触发整套流程\n"},"云计算/DevOps/Gitlab容器部署配置":{"slug":"云计算/DevOps/Gitlab容器部署配置","filePath":"云计算/DevOps/Gitlab容器部署配置.md","title":"Gitlab容器部署配置","links":["Linux系统配置与调优/CentOS7.9-命令杂项"],"tags":["云原生","Docker","CICD"],"content":"\n一、简介\n配置环境如下：\n系统问题、代理配置等请参考CentOS7.9 命令杂项\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n系统及软件环境版本CentOS7.9Docker20以上的版本即可GitLab镜像gitlab/gitlab-ce:16.1.0-ce.0\n\n二、GitLab部署配置\n1. 运行GitLab容器\n\n\n                  \n                  NOTICE\n                  \n                \n\n\n1）—privileged 若运行时Gitlab容器一直重启，添加可解决\n2）8080:80  外部http访问端口变为8080，2222:22 外部ssh访问端口变为2222\n3）将持久化文件路径挂载出来（你也不想代码仓库随着容器一起消失吧 😰）\n\n\n\ndocker run -d \\\n\t--privileged  --hostname localhost \\\n\t-p 8080:80  -p 2222:22  --name gitlab \\\n\t--restart always   \\\n\t-v /opt/gitlab/config:/etc/gitlab   \\\n\t-v /opt/gitlab/logs:/var/log/gitlab   \\\n\t-v /opt/gitlab/data:/var/opt/gitlab   \\\n\tgitlab/gitlab-ce:16.1.0-ce.0\n2. 修改GitLab容器内部配置\n\n进入容器内部：\n\ndocker exec -it gitlab bash\n\n修改文件：\n\nvi /etc/gitlab/gitlab.rb\n\n添加如下配置项：\n\ngitlab_rails[&#039;gitlab_shell_ssh_port&#039;] = 外部ssh访问端口                 \nexternal_url &#039;http://宿主机或公网ip:外部http访问端口&#039;                    \nnginx[&#039;listen_port&#039;] = 容器内gitlab服务端口\n \n例子:\ngitlab_rails[&#039;gitlab_shell_ssh_port&#039;] = 2222                     \nexternal_url &#039;http://192.168.137.11:8080&#039;                          \nnginx[&#039;listen_port&#039;] = 80\n\n\n                  \n                  WARNING\n                  \n                \n\n\n以上ip和port配置是与运行容器时的配置相关\n\\qquad 1.若为更改http和ssh端口，则无需更改。其中修改gitlab_rails与external_url，在复制git仓库的clone地址时，直接相关，当复制clone地址时，则会变为\nssh://git@外部ip:外部ssh端口/用户/项目.git 和\nhttp://外部ip:外部http端口/用户/项目.git\n\\qquad 2.如果更改了外部http端口，external_url ‘http://192.168.137.11:8080’ 配置项改成带端口的，改成非80端口，则必须添加 nginx[‘listen_port’] = 80 ，因为external_url带端口则会让容器内的nginx监听改的端口，但运行容器时是 -p 8080:80，则外部一定访问不到Gitlab服务\n\\qquad 3.nginx[‘listen_port’] 此项在更改外部http端口时，必须添加，否则外部访问不到Gitlab服务\n\n\n\n//修改另一配置 （顺便修改下吧）\nvi /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml\n//ssh外部端口\nssh_port: 2222\n\n配置生效、重启Gitlab服务\n\n//在容器内 重新生成配置\ngitlab-ctl reconfigure\n//重启服务\ngitlab-ctl restart\n\n此时外部网页http://ip:port能够访问到Gitlab服务了\n\n3. 配置管理员用户\n\n进入容器内部\n\ncd /opt/gitlab/bin\ngitlab-rails console //等待初始化密码\n\n终端输入，查找管理员用户\n\nu=User.where(id:1).first\n//可以查看到管理员用户名，一般为root\n\n设置管理员密码\n\nu.password=&#039;xxxxxxxxx&#039;\n\n确认密码\n\nu.password_confirmation=&#039;xxxxxxxxx&#039;\n\n保存修改\n\nu.save!\n4. 创建新用户与项目仓库\n\n注册新用户，使用管理员认证通过\n创建代码仓库\n本地与git仓库关联\n创建ssh公钥私钥\n\nssh-keygen -o -t rsa -b 2048 -C &quot;email@example.com&quot;\n\n将生成的id_rsa.pub复制到代码仓库的SSH Keys上\n\n\n\n                  \n                  WARNING\n                  \n                \n\n\n\\qquad如果Gitlab与Jenkins部署在内网，那么需要使用管理员配置出站请求\n\\qquad步骤如下(管理员登录)：\nAdmin area → Setting → Network → Outbound requests\n勾选允许webhook出站到内网地址\n\n\n\n\n也可不用ssh key，本地与gitlab关联走http，推送时使用有权限推送的成员用户名和密码\n"},"云计算/DevOps/Jenkins容器部署配置":{"slug":"云计算/DevOps/Jenkins容器部署配置","filePath":"云计算/DevOps/Jenkins容器部署配置.md","title":"Jenkins容器部署配置","links":["Linux系统配置与调优/CentOS7.9-命令杂项"],"tags":["云原生","CentOS","CICD"],"content":"\n一、简介\n配置环境如下：\n系统问题、代理配置等请参考CentOS7.9 命令杂项\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n系统及软件环境版本CentOS7.9Docker20以上的版本即可Jenkins镜像jenkins/jenkins:lts\n\n二、Jenkins部署与配置\n1.运行Jenkins容器\ndocker run -d --name=jenkins \\\n-p 8080:8080 \\\n-u root \\\n--restart always \\ n\n-v /var/run/docker.sock:/var/run/docker.sock \\\n-v /usr/bin/docker:/usr/bin/docker \\\n-v /opt/jenkins_home:/var/jenkins_home \\\njenkins/jenkins:lts\n2.配置Jenkins\n2.1获取管理员密码，网页访问并输入密码解锁Jenkins\ncat /opt/jenkins_home/secrets/initialAdminPassword\n或者进入容器\ncat /var/jenkins_home/secrets/initialAdminPassword\n2.2 安装插件\n1）直接选安装推荐插件，等待安装完毕\n2）创建管理员用户 admin\n3）安装其他插件\n系统管理 → 插件管理 → 可选插件搜索框，搜索并安装以下插件：\n\nGitlab   Gitlab API\nDocker\nPublish Over SSH\n\n2.3创建Jenkins任务\n2.3.1 创建freestyle项目\n输入项目名称xxx，选择freestyle项目。名字最好能与Gitlab的项目对应\n2.3.2 配置freestyle项目\n2.3.2.1 配置源码管理\n源码管理选择Git\n\\qquadRepository URL：此处可以填入Gitlab项目的ssh或者http两种地址区别为\n\\qquad 1）填入http地址，则Jenkins凭证选择Gitlab创建项目的用户或有权限提交的用户和其密码连接Github\n\\qquad 2）填入ssh地址，则在Jenkins凭证中用户填入git，私钥选择与Gitlab项目配对的私钥，且需要在容器内使用私钥连接一次后，添加目标服务器的指纹到known_hosts文件中，网页配置生效。\n\\qquad私钥挂载或复制进容器，进入容器执行后，可添加目标服务器的指纹到known_hosts文件：\nssh -i /path/to/private_key -p 2222 git形式的项目地址\n2.3.2.2 配置触发器\n\n勾选Build when a change is pushed to GitLab … 同时记得 GitLab webhook URL\n下翻点击Generate，生成token\n切到Gitlab，在项目中Setting → Webhooks，填入上述URL和token，勾选适当的触发条件(Push events等)，下拉最后点击确定，生成webhooks，点击edit后，能看到历史触发的详细信息。点击test，可以发送对应的触发事件，用来手动测试联通Jenkins的流水线或其他任务\n\n2.3.2.3 配置构建\n\\qquad这里主要是配置C++/CMake构建项目。所以 build step 勾选 执行shell\n输入如下：\n#!/bin/bash\nset -ex\n \nHOST_PATH=&quot;/opt/jenkins_home/workspace/hello&quot;\n \ndocker run --rm \\\n  -v &quot;$HOST_PATH&quot;:/build \\\n  -w /build \\\n  cpp-build-image:v1 bash ./build.sh\n\\qquad本地自行准备好编译环境的镜像，另外此处是Jenkins容器挂载目录/opt/jenkins_home:/var/jenkins_home，相应的Jenkins拉取的Gitlab项目会在容器内的/var/jenkins_home/workspace/项目名 ，也就是宿主机的/opt/jenkins_home/workspace/项目名，选择运行编译容器时，将Gitlab项目目录由宿主机挂载进编译容器，且工作目录进入项目目录下，此处需开发人员将构建命令自行准备好，且随项目一同提交进Gitlab。执行过程中，编译完成的可执行文件和库都会在宿主机的/opt/jenkins_home/workspace/项目名 目录下，取决于 build.sh的构建细节。后续可将构建的产物继续打包或上传\n\n\n                  \n                  Jenkins的构建步骤里，build step可以是一个或多个，因此可以拆分多步，也可以一步构建完，然后使用docker build打包 \n                  \n                \n\n\n\n                  \n                  build step比较自由，主要服务于最终的目的，能达成目的即可 \n                  \n                \n\n"},"云计算/DevOps/ROS2+PX4安装配置及开发环境搭建":{"slug":"云计算/DevOps/ROS2+PX4安装配置及开发环境搭建","filePath":"云计算/DevOps/ROS2+PX4安装配置及开发环境搭建.md","title":"ROS2+PX4安装配置及开发环境搭建","links":["Linux系统配置与调优/CentOS7.9-命令杂项"],"tags":["ROS2","PX4","中间件"],"content":"\n一、简介\n\n配置环境如下：\n\nUbuntu22.04\nROS2 Humble\nPX4\nGazebo Ignition （gz sim8.9）\nQGroundControl\nMicroXRCEAgent\n\n\n最终完成多无人机数据转发接入ROS2\n\n\n                  \n                  WARNING\n                  \n                \n\n\n所有安装操作均为普通用户，非root用户下进行\n\n\n\n系统问题、代理配置等请参考CentOS7.9 命令杂项\n\n二、PX4源码下载编译\n\n拉源码\n\ngit clone github.com/PX4/PX4-Autopilot.git --recursive\n\n安装依赖\n\nbash ./PX4-Autopilot/Tools/setup/ubuntu.sh\n\n安装ant、安装jdk11\n\nsudo apt install ant openjdk-11-jdk\n\n编译\n\ncd PX4-Autopilot\nmake px4_sitl jmavsim\n\n看到jmavsim运行即为成功\n终端输入命令，可以看到起飞、降落、关闭\n\ncommander takeoff/land/shutdown\n\n三、ROS2安装\n按照流程安装ROS2 Humble版本\nwget fishros.com/install -O fishros &amp;&amp; . fishros\n\n四、安装Gazebo Ignition\n1. 安装配置\n1.1 安装\ncd ~/PX4-Autopilot\nsudo wget packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg\nsudo apt-get update\nsudo apt-get install gz-garden\n\n\n                  \n                  可能会提示已安装，软件能看到Gazebo Sim8即可 \n                  \n                \n\n1.2 下载启动脚本\nwget raw.githubusercontent.com/PX4/PX4-gazebo-models/main/simulation-gazebo\n1.3 运行脚本拉起Gazebo Sim\npython3 simulation-gazebo\n2. 配置问题\n\n\n                  \n                  若不配置，make px4_sitl gz_x500 或者 python3 simulation-gazebo会闪退 \n                  \n                \n\n\nGazebo-GL问题\n错误信息： OpenGL 3.3 is not supported. Please update your graphics card drivers.\n解决方案：\n\nvim ~/.bashrc\n//添加:\nexport MESA_GL_VERSION_OVERRIDE=3.3\nsource ~/.bashrc\n\nGazebo闪退\n错误信息： 按上述步骤操作之后，将不再提示错误信息，但Gazebo还是会闪退\n解决方案：\n\nvim ~/.bashrc\n//添加:\nexport PX4_GZ_SIM_RENDER_ENGINE=ogre\nsource ~/.bashrc\n\n五、MicroXRCE-DDS Agent的安装\n\n下载源码\n\ngit clone github.com/eProsima/Micro-XRCE-DDS-Agent.git\n\n编译\n\ncd Micro-XRCE-DDS-Agent \nmkdir build &amp;&amp; cd build\ncmake .. &amp;&amp; make -j8\n\n安装\n\nsudo make install\nsudo ldconfig /usr/local/lib/\n\n六、QGC地面站安装\n\n\n                  \n                  必须是非root的普通用户执行安装 \n                  \n                \n\n\n安装依赖 ubuntu20以上版本：\n\nsudo usermod -a -G dialout $USER\nsudo apt-get remove modemmanager -y\nsudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y\nsudo apt install libfuse2 -y\nsudo apt install libxcb-xinerama0 libxkbcommon-x11-0 libxcb-cursor0 -y\n\n\n重启生效\n\n\n下载安装包   去官网QGC Guide (master) 找到linux安装包QGC_Linux\n\n\nwget d176tv9ibo4jno.cloudfront.net/latest/QGroundControl.AppImage\n\n安装运行\n\nchmod +x ./QGroundControl.AppImage \n./QGroundControl.AppImage\n\n七、Offboard测试、开发\n1.开发环境搭建\n\n创建ROS2工作空间\n\nmkdir -p ~/ros2_ws/src\n\n下载源码\n\ncd ~/ros2_ws/src\ngit clone github.com/PX4/px4_msgs.git \ngit clone github.com/PX4/px4_ros_com.git \n\n\n                  \n                  WARNING\n                  \n                \n\n\n\n不要随便切分支，px4_msgs里的msg数据格式必须与PX4_Autopilot里的msg数据格式对应\n分支版本对应关系请查看  px4_msgs版本对应关系\n否则会报错：[RTPS_READER_HISTORY Error] Change payload size of ‘164’ bytes is larger than the history payload size of ‘151’ bytes and cannot be resized. → Function can_change_be_added_nts\n\n\n\n\n\n编译\n\ncd ~/ros2_ws\ncolcon build\n\n配置环境变量\n\necho &quot;source ~/ros2_ws/install/setup.bash&quot; &gt;&gt; ~/.bashrc \nsource ~/.bashrc\n2. 单机测试\n\n\n                  \n                  运行成功后，可以看到Gazebo Sim中无人机起飞到5m \n                  \n                \n\n\n开启QGC地面站\n\n./QGroundControl.AppImage\n\n开启通信中转\n\nMicroXRCEAgent udp4 -p 8888\n\n开启px4仿真\n\ncd ~/PX4_Autopilot\nmake px4_sitl gz_x500\n\n运行px4的Offboard模式源码\n\nros2 run px4_ros_com offboard_control\n3.多机测试\n\n启动QGC地面站\n\n./QGroundControl.AppImage\n\n脚本拉起Gazebo Sim\n\npython3 simulation-gazebo\n\n启动PX4无人机\n\n\n\n                  \n                  NOTICE\n                  \n                \n\n\n3.1 PX4_GZ_STANDALONE=1表明我们使用standalone启动，不启动仿真，只启动PX4，会自动在Gazebo中添加飞机\n3.2 PX4_SYS_AUTOSTART=4001为必须字段\n3.3 PX4_GZ_MODEL_POSE=“0,2”表示无人机的位置，注意不同的飞机位置应该不一样\n3.4 PX4_SIM_MODEL=gz_x500指定了飞机模型为x500\n3.5 要为多机仿真的每一架无人机给定一个单独的编号，这里为 -i 0，即第0号无人机\n\n\n\n启动第1架无人机\ncd ~/PX4-Autopilot\nPX4_GZ_STANDALONE=1 PX4_SYS_AUTOSTART=4001 PX4_GZ_MODEL_POSE=&quot;0,1&quot; PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i 1\n启动第n架无人机\ncd ~/PX4-Autopilot\nPX4_GZ_STANDALONE=1 PX4_SYS_AUTOSTART=4001 PX4_GZ_MODEL_POSE=&quot;0,-1&quot; PX4_SIM_MODEL=gz_x500 ./build/px4_sitl_default/bin/px4 -i n\n此时在每个px4终端，都可以输入 commander takeoff/land 控制无人机起降\n\n添加通信桥接\n\nMicroXRCEAgent udp4 -p 8888\n\nros2数据接入\n\n\n此时可以在看到无人机的topic，且命名空间为px4_编号\n\nros2 topic list\n\nros2订阅消息，可以看到打印输出\n\nros2 topic echo /px4_1/fmu/out/vehicle_gps_position\nros2 topic echo /px4_2/fmu/out/sensor_combined"},"云计算/DevOps/单节点Docker部署etcd服务":{"slug":"云计算/DevOps/单节点Docker部署etcd服务","filePath":"云计算/DevOps/单节点Docker部署etcd服务.md","title":"单节点Docker部署etcd服务","links":[],"tags":["中间件"],"content":"拉取镜像\ndocker pull swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/bitnami/etcd:3.5\n\ndocker tag  swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/bitnami/etcd:3.5  bitnami/etcd:3.5\n\n构建etcd服务端容器\ndocker run -d --name=etcd-server \\\n-e ALLOW_NONE_AUTHENTICATION=yes \\\nbitnami/etcd:3.5 \\\netcd\n构建etcd客户端容器，用于测试\ndocker run -d --name=etcd-client \\\n-e ALLOW_NONE_AUTHENTICATION=yes \\\nbitnami/etcd:3.5 \\\netcd\n客户端容器内，操作etcd-server\netcdctl --endpoints=http://172.17.0.2:2379 put /mykey &quot;value&quot;\n \netcdctl --endpoints=http://172.17.0.6:2379 get /mykey\n# 获取全部以mykey为前缀的value\netcdctl --endpoints=http://172.17.0.6:2379 get /mykey --prefix\n代码块测试\n{\n    &quot;command&quot;:&quot;engine_step&quot;,\n    &quot;args&quot;:{\n        [\n            &quot;x&quot;:1,\n            &quot;y&quot;:2\n        ]\n    }\n}"},"云计算/K8S/Ubuntu20.04安装MiniKube":{"slug":"云计算/K8S/Ubuntu20.04安装MiniKube","filePath":"云计算/K8S/Ubuntu20.04安装MiniKube.md","title":"Ubuntu20.04安装MiniKube","links":[],"tags":["中间件","K8S","MiniKube"],"content":"安装Docker (阿里云镜像)\n1.卸载Docker旧版本\nsudo apt-get remove docker docker-engine docker-ce docker.io\n2.添加阿里云GPG秘钥\ncurl -fsSL mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -\n3.设置存储库\nsudo add-apt-repository &quot;deb [arch=amd64] mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;\n4.安装docker\nsudo apt-get update\n \nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n5.验证\nsudo docker version\n \nsudo systemctl status docker，未运行时执行sudo systemctl start docker启动docker\n \nsudo docker run hello-world 运行个容器试下\n \nsudo systemctl enable docker  # 设置开机自启\n6.添加阿里镜像加速\nsudo vim /etc/docker/daemon.json\n#添加：\n{\n    &quot;registry-mirrors&quot;: [\n            &quot;docker.211678.top&quot;,\n            &quot;docker.1panel.live&quot;,\n            &quot;hub.rat.dev&quot;,\n            &quot;docker.m.daocloud.io&quot;,\n            &quot;do.nark.eu.org&quot;,\n            &quot;dockerpull.com&quot;,\n            &quot;dockerproxy.cn&quot;,\n            &quot;docker.awsl9527.cn&quot;\n      ]\n}\n \nsudo systemctl daemon-reload\nsudo systemctl restart docker\n安装MiniKube\n{% note color:warning MiniKube中文文档 %}\n{% note color:error MiniKube中文文档 %}\n1.依赖\nsudo apt-get install -y apt-transport-https\n2.添加阿里GPG\nsudo curl mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -\n3.添加阿里apt源\nsudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;-&#039;EOF&#039; \ndeb mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main \nEOF\n \nsudo apt-get update\n4.安装kubectl\nsudo apt-get install -y kubectl\n5.添加用户到docker组\nsudo usermod -aG docker $USER &amp;&amp; newgrp docker\n6.安装mibikube\ncurl -LO storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64\n \nsudo install minikube-linux-amd64 /usr/local/bin/minikube\n7.启动minikube\nminikube start --driver=docker --image-mirror-country=cn --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers --kubernetes-version=1.23.8\n注：结合docker使用时，k8s版本最好不要用1.24及以上版本，k8s从1.24版本开始不在直接兼容docker，需要安装cri-docker。\n为了方便，设置alias\nsudo vim ~/.bashrc\n#添加：\nalias minikube.cn=&quot;minikube start --image-mirror-country=cn --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers --kubernetes-version=1.23.8&quot;\nalias kubectl=&quot;minikube kubectl --&quot;\n#生效\nsource ~/.bashrc"}}